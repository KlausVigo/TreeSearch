---
title: "Phy101: Introduction to Parsimony"
author: "Martin R. Smith"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_width: 7
    fig_height: 5
bibliography: ../inst/REFERENCES.bib
csl: ../inst/apa-old-doi-prefix.csl
vignette: >
  %\VignetteIndexEntry{Phy101: Introduction to Parsimony}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Background ##

For an initial introduction to phylogenetics, I recommend Berkley's
"Understanding Evolution" resources, in particular:

- [Evolutionary trees: A primer](
https://evolution.berkeley.edu/the-tree-room/evolutionary-trees-a-primer/)
- [Tree misinterpretations](
  https://evolution.berkeley.edu/the-tree-room/tree-misinterpretations/)
- [How to build a tree](
  https://evolution.berkeley.edu/the-tree-room/how-to-build-a-tree/)


## Reconstructing evolutionary history ##

To reconstruct evolutionary history, we must first infer the pattern of
relationships between taxa.  This phylogenetic framework may then allow us to
explore the timing, rate and pattern of evolutionary processes.

To reconstruct a tree, we require data, in the form of observations from the
taxa of interest. Tree inference is most effective when we combine
morphological observations with molecular sequence data [e.g. @Asher2022].
Fossil taxa are particularly important at resolving deep relationships
[e.g. @Koch2020], whose phylogenetic signature is overprinted by the passing of
evolutionary time.


## Analysing molecular data ##

Nucleotide sequences (e.g. the A/C/G/T bases of DNA) evolve in a predictable and
observable fashion.  As such, their evolution can be modelled statistically,
making it possible to assign a probabilistic likelihood to any given
phylogenetic tree. Data are usually aligned using either maximum likelihood,
which seeks to find the single most likely tree topology, or Bayesian methods,
which sample a subset of trees in proportion to their probability, and thus
allow uncertainty in tree reconstruction to be depicted.

As an illustration, assume a friend tells you that they are driving to the
shops.  Where could you expect to locate their car in 30 minutes' time?
A Bayesian approach could assign a probability to each car parking space within
30 minutes' drive of their home. Given the thousands of possibilities, no single
space will have a particularly high probability; but by summarising the results,
it might be possible to conclude with say 75% probability that the car will be
close to a particular supermarket.

A maximum likelihood approach would simply return the single most likely
location of the car, which might not be representative of the broader
probability distribution: 
here, the small possibility that your friend's car won't start may nevertheless
be greater than the probability associated with any one of the thousands of
possible parking spaces, so the most likely single location for the
car would be your friend's front drive.

Because maximum likelihood analysis is much faster to conduct than Bayesian
analysis, it is widely used, even if its results require caution to interpret,
and uncertainty is harder to characterize.


## Analysing morpological data with parsimony ##

Morphological data do not lend themselves particularly well to modelling.
Because different morphological features are likely to evolve in different ways,
a realistic model of morphological evolution is difficult to construct, and
would likely contain more unknown parameters besides tree topology than could
reasonably be reconstructed from a typical morphological dataset.
Even if simple models can do a decent job of reconstructing trees
[e.g. @Goloboff2018;@Sansom2018;@Smith2019], parsimony methods are more
widely used to infer phylogeny from morphological datasets.

In essence, maximum parsimony asserts that the simplest tree is correct.
(For a justification of this philosophy, see @Haber2021.)
What is the simplest tree? Under the equal weights paradigm, this is the tree
that implies the fewest character transformations.

- Exercise: Colour the branches in the trees below in order to minimize the
  number of places where the colour changes.

```{r char-changes}
par(mar = rep(0, 4), mfrow = c(1, 2))
tree1 <- TreeTools::BalancedTree(rep(c("orange", "blue"), each = 4))
plot(tree1, tip.col = tree1$tip.label)
tree2 <- TreeTools::PectinateTree(rep(c("red", "grey"), length.out = 8))
plot(tree2, tip.col = tree2$tip.label)
```

- Exercise: How many changes in colour does each tree require?  Which tree is
  the most parsimonious?
  
To score a tree, we sum all necessary changes in all characters.

The falsification view of parsimony asserts that each character in a dataset
represents a statement of homology, and thus falsifies any tree in which the
character evolves more than once: if "blue" evolved twice, then it should be
coded as two separate blues in the dataset.
In practice, however, it is very rare for all morphological characters to be
compatible: that is to say, no tree exists in which all characters can be
reconstructed without homoplasy.

If all trees are falsified, then some of our characters must code homoplasies,
where they should only contain traits with a single change on the true tree.
But is it not necessarily straightforward to identify which characters might 
contain homoplasies and should thus be recoded or discarded.
Of course, even if a character does contain homoplasy, it may still
contain some phylogenetic information: even if you're not sure which "blue" a
taxon exhibits, its blueness does at least exclude it from an orange region
of the tree.

The alternative justification of parsimony invokes Ockham's razor to assert
that the "simplest" solution is always the best.
This assumes that change is equally likely in all characters: that is, that
all characters are equally likely to evolve, or equally likely to represent
homology statements.

- Exercise: Consider the two trees below.  What colour would you expect the
  unlabelled tip to exhibit in each tree?  For which character are you most
  confident in your answer?


```{r char-reliability}
library("TreeTools", quietly = TRUE, warn.conflicts = FALSE)
set.seed(11)
par(mar = rep(0, 4), mfrow = c(1, 2))
tree1 <- BalancedTree(c(rep("orange", 8), rep("blue", 7), "0"))
plot(tree1, tip.col = tree1$tip.label)
tree2 <- BalancedTree(c(sample(c("red", "grey"), 15, replace = TRUE), "0"))
plot(tree2, tip.col = tree2$tip.label)
```


Now consider two trees: one tree proposes that nine characters each exhibit
a single additional step â€“ in total, that's nine evolutionary events more than
we'd see if all characters lacked homoplasy.
The second tree also contains nine "extra" evolutionary events, but all these
occur in a single character.

- Exercise: Which tree represents a more parsimonious evolutionary scenario?
  Which evolutionary scenario do you consider more plausible?


If we expect evolutionary change to be clustered in "unreliable" characters,
but we can't (or don't want to) estimate how reliable characters _a priori_,
we can use concave weighting functions that assign less penalty to each
additional step beyond the first.
Implied weights [@Goloboff1993] and profile parsimony [@Faith2001]
are two approaches that can be used; see the function [`IWScore()`](
https://ms609.github.io/TreeSearch/reference/TreeLength.html) or the 
vignette on [profile parsimony](
https://ms609.github.io/TreeSearch/articles/profile.html) for more details.

In empirical studies, implied weighting tends to produce "better" trees than
equal weights [@Goloboff2018;@Smith2019]; yet some researchers deem it "impure"
and equal weights is probably more widely used.


## Strict consensus trees ##

In its pursuit of a single optimal tree, maximum parsimony has something in
common with maximum likelihood -- even if there sometimes exist multiple
equally parsimonious trees that must be summarised using consensus methods.

If multiple trees are equally parsimonious, how can we summarise our 
best understanding of evolutionary history?
One approach is to take the strict consensus all all our most parsimonious
trees.
A strict consensus tree contains only the edges (branches) that occur in each
of the input trees.

- Exercise: Calculate the strict consensus of the two trees below.

```{r ex-strict-cons}
tree1 <- ape::read.tree(text = "((((a, b), x), c), (d, (e, (f, (g, h)))));")
tree2 <- ape::read.tree(text = "(((a, b), c), (d, (e, (x, ((f, h), g)))));")
par(mar = rep(0, 4), mfrow = c(1, 2))
plot(tree1)
plot(tree2)
```

A strict consensus tree can conceal structure that is in fact held in common
between all input trees, suggesting more uncertainty than truly exists.

- Exercise: Identify a tree that is consistent with the strict consensus
  tree, but does not belong to the set of input trees.  Is this new tree
  necessarily as parsimonious as the input trees?

A single taxon with an uncertain phylogenetic position can reduce the resolution
of a consensus tree.  Sometimes the information we lose by omitting the leaf
from our consensus tree is compensated by the information we gain regarding the
relationships between other taxa.

- Exercise: Construct a "reduced" strict consensus tree by removing leaf _x_
  from each of the input trees, then computing the consensus of the reduced
  tree.
  What information do you gain by omitting _x_?
  What information is lost in the reduced tree?
  
- Extension exercise: Find another taxon whose removal reduces causes a
  polytomy in the strict consensus to become resolved.
  What information do you gain by omitting this taxon?
  What information is lost in the reduced tree?
  Is the removal of this taxon from the consensus justified?
  
The net information gained by removing such "rogue" taxa can be calculated
using information theory [@SmithCons]; you may wish to explore the "[Rogue](
https://ms609.github.io/Rogue/)" R package.


## Further Reading ##

History and philosophy of phylogenetic methods: @Haber2021

## References ##
